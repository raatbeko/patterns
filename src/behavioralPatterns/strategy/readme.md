**Strategy (Стратегия)** — это поведенческий паттерн проектирования, который определяет семейство схожих алгоритмов,
инкапсулирует их в отдельные классы и делает их взаимозаменяемыми. Таким образом, объект может выбирать или менять
алгоритм на лету, не зная деталей его реализации.

---

### Основная идея:

Паттерн позволяет вынести различные алгоритмы в отдельные классы, а объект-клиент использует их через общий интерфейс.
Вместо того чтобы содержать логику выбора алгоритма в самом объекте, она делегируется внешним объектам — стратегиям.

---

### Для чего нужен:

1. **Замена сложных условных конструкций** — вместо множества `if-else` или `switch` выбирается нужная стратегия.
2. **Гибкость** — добавление новых алгоритмов (стратегий) не требует изменения кода клиента.
3. **Повышение читаемости** — алгоритмы изолированы в отдельные классы, что упрощает их понимание и тестирование.

---

### Пример из жизни:

Представь маршрут в навигаторе:

- Ты можешь выбрать, как добраться из точки А в точку Б:
    1. На машине.
    2. На велосипеде.
    3. Пешком.

Каждый из этих вариантов — это **стратегия**, которая определяет алгоритм расчёта маршрута. Навигатор сам не
рассчитывает маршрут, он делегирует задачу соответствующей стратегии.

---

### Как это работает:

1. **Контекст (Context)** — объект, который содержит ссылку на текущую стратегию. Он не знает, как работает стратегия, а
   лишь вызывает её метод.
2. **Стратегия (Strategy)** — общий интерфейс для всех алгоритмов.
3. **Конкретные стратегии (Concrete Strategy)** — классы, реализующие различные алгоритмы.

---

### Где используется:

1. **Алгоритмы расчёта** — например, разные способы сортировки данных.
2. **Оптимизация процессов** — выбор оптимальной стратегии в зависимости от условий (например, стратегии поиска в
   больших данных).
3. **Игры** — выбор поведения персонажа (атаковать, защищаться, убегать).
4. **UI/UX** — выбор разных стилей отображения интерфейса (например, тёмная или светлая тема).

---

### Преимущества:

1. **Изоляция логики** — алгоритмы вынесены в отдельные классы, их проще тестировать и изменять.
2. **Лёгкость добавления новых стратегий** — достаточно создать новый класс.
3. **Гибкость выбора** — можно менять алгоритм на лету без изменения кода клиента.

---

### Недостатки:

1. **Увеличение количества классов** — для каждой стратегии нужно создавать отдельный класс.
2. **Усложнение кода** — в простых случаях использование паттерна может быть избыточным.

---

### Пример из реальной жизни:

Представь, ты платишь в магазине. У тебя есть разные способы оплаты:

- Наличные.
- Банковская карта.
- Электронные деньги.

Каждый из этих способов — это стратегия. Клиент (касса) не знает, как работает каждая из стратегий, но она вызывает
нужную в зависимости от выбора пользователя.

---

### Как это может выглядеть в реальном приложении:

1. У тебя есть список данных, и ты хочешь их отсортировать.
2. В зависимости от размера данных ты выбираешь стратегию:
    - Если данных мало, используется **быстрая сортировка**.
    - Если данных много, используется **поразрядная сортировка**.
3. Программа переключается между стратегиями на основе входных данных.

---

### Отличие от других паттернов:

- В отличие от **State**, где объект меняет своё состояние и, соответственно, поведение, в **Strategy** поведение
  меняется на основе выбора пользователя или условий.
- В отличие от **Command**, здесь нет истории операций или возможности отмены, только выбор алгоритма.

---