**State (Состояние)** — это поведенческий паттерн проектирования, который позволяет объекту изменять своё поведение в
зависимости от своего текущего состояния. При этом состояние самого объекта можно рассматривать как отдельный объект.

---

### Основная идея:

Объект ведёт себя по-разному в зависимости от того, в каком состоянии он находится. Вместо того чтобы использовать
громоздкие конструкции `if-else` или `switch`, каждое состояние инкапсулируется в отдельный класс, а объект делегирует
выполнение своих действий текущему состоянию.

---

### Для чего нужен:

1. **Избавиться от сложных условий** — уменьшает использование `if-else` конструкций, связанных с поведением объекта.
2. **Инкапсуляция логики** — логика для каждого состояния изолирована, что делает код чище и удобнее для понимания.
3. **Изменение поведения на лету** — позволяет динамически менять поведение объекта в зависимости от его состояния.

---

### Пример из жизни:

Представь работу кофемашины. У неё есть несколько состояний:

1. **Ожидание монеты** — машина ничего не делает, пока не вставлена монета.
2. **Приготовление кофе** — после вставки монеты начинается процесс приготовления.
3. **Выдача кофе** — после приготовления кофе машина выдаёт напиток.
4. **Неисправность** — если произошла ошибка, машина не работает.

Каждое из этих состояний определяет, как машина реагирует на действия пользователя, например, нажатие кнопки или вставку
монеты.

---

### Как это работает:

1. **Контекст** — объект, который меняет своё поведение. Он содержит ссылку на текущий объект состояния.
2. **Состояния** — несколько классов, представляющих разные варианты поведения.
3. **Переключение состояний** — контекст делегирует выполнение текущему состоянию, а состояние может сменить контекст на
   другое состояние.

---

### Где используется:

1. **Игры** — персонаж в игре может быть в состоянии "бег", "прыжок" или "атака", и его поведение меняется в зависимости
   от состояния.
2. **Автоматизированные системы** — например, банкомат (ожидание карты, ввод PIN, выдача наличных).
3. **UI/UX** — интерфейс может вести себя по-разному в зависимости от текущего состояния (например, кнопка "Войти"
   меняется на "Выйти" после авторизации).
4. **Производственные процессы** — конвейер может переключаться между состояниями "ожидание", "работа" или "авария".

---

### Преимущества:

1. **Изоляция логики** — код каждого состояния независим, что упрощает его поддержку.
2. **Расширяемость** — можно легко добавлять новые состояния, не изменяя существующий код.
3. **Упрощение кода контекста** — избавление от громоздких условий в контексте.

---

### Недостатки:

1. **Увеличение количества классов** — для каждого состояния создаётся отдельный класс.
2. **Может быть избыточным** — если состояний немного, то использование этого паттерна может оказаться сложнее, чем
   просто `if-else`.

---

### Пример из реальной жизни:

Представь световой светофор. У него есть три состояния:

- Красный.
- Жёлтый.
- Зелёный.

В каждом состоянии светофор ведёт себя по-разному:

- Красный — машины стоят.
- Жёлтый — машины готовятся ехать.
- Зелёный — машины движутся.

Каждое из этих состояний можно представить отдельным классом, а сам светофор будет переключаться между этими
состояниями.

---

### Отличие от других паттернов:

- В отличие от **Strategy**, где логика поведения выбирается вручную, в **State** поведение автоматически изменяется на
  основе состояния объекта.
- В отличие от **Observer**, здесь нет подписчиков, но есть строгая связь между контекстом и состояниями.

---