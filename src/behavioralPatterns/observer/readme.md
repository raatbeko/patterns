**Observer (Наблюдатель)** — это паттерн проектирования, который создаёт механизм подписки, позволяя одним объектам
следить за изменениями состояния других объектов. Этот паттерн полезен, когда нужно уведомлять множество объектов о
событиях, происходящих в другом объекте, **без тесной связи между ними**.

---

### Основная идея:

Есть объект (называемый **издатель**, или **субъект**), который хранит своё состояние. Другие объекты (называемые *
*наблюдатели**) хотят быть уведомлены, когда это состояние изменяется. Издатель "рассылает" уведомления наблюдателям о
своём изменении.

---

### Для чего нужен:

1. **Реакция на события** — позволяет одним объектам реагировать на изменения в другом объекте.
2. **Разделение обязанностей** — издатель и наблюдатели работают независимо друг от друга, что упрощает
   масштабируемость.
3. **Изоляция компонентов** — объекты не зависят друг от друга напрямую.

---

### Пример из жизни:

Представь, что ты подписался на обновления акций компании. Каждый раз, когда меняется курс акций:

- Брокер отправляет тебе уведомление.
- Ты можешь принять решение (купить или продать акции).

В этой ситуации брокер — это **издатель**, а ты (и другие клиенты) — **наблюдатели**.

---

### Как это работает:

1. У тебя есть **издатель (subject)**, который:
    - Хранит список подписчиков (наблюдателей).
    - Уведомляет их, когда происходит какое-то событие.
2. **Наблюдатели (observers)** подписываются на изменения издателя и выполняют свои действия, когда получают
   уведомление.
3. Когда состояние издателя меняется, он:
    - Проходит по списку подписчиков.
    - Сообщает каждому о своём изменении.

---

### Где используется:

1. **Графические интерфейсы** — например, кнопка уведомляет слушателей, когда на неё нажали.
2. **Игры** — например, изменение состояния персонажа может уведомлять других объектов (например, отображение на экране
   или звуковые эффекты).
3. **Модели данных** — если данные изменяются, интерфейс (или другие компоненты) должен быть автоматически обновлён.
4. **Уведомления в реальном времени** — например, подписка на события в социальных сетях или биржевые уведомления.

---

### Преимущества:

1. **Слабая связанность** — издатель не знает, кто именно следит за его состоянием, он лишь уведомляет об изменениях.
2. **Расширяемость** — можно добавить новых наблюдателей без изменения кода издателя.
3. **Динамическая подписка** — можно подписывать или отписывать наблюдателей в любое время.

---

### Недостатки:

1. **Потенциальная сложность** — с большим количеством наблюдателей код может стать сложным для отладки.
2. **Проблемы с производительностью** — если наблюдателей много или они выполняют сложные действия, это может замедлить
   работу системы.
3. **Риск утечек памяти** — если наблюдатели не отписываются от издателя, может возникнуть проблема с освобождением
   памяти.

---

### Пример из реальной жизни:

Допустим, ты ведёшь Telegram-канал:

- Ты (канал) — это **издатель**.
- Твои подписчики — это **наблюдатели**.
- Когда ты публикуешь новый пост, все подписчики сразу получают уведомление.

Если подписчик устал от твоих постов, он может **отписаться**, и ты больше не будешь его уведомлять.

---

### Отличие от других паттернов:

- В отличие от **Mediator**, где взаимодействие идёт через центральный объект, в Observer связь между издателем и
  наблюдателями устанавливается напрямую.
- В отличие от **Publisher-Subscriber** (который похож), в Observer чаще используется синхронное уведомление, а не через
  внешние брокеры сообщений.

---